<!doctype html>
<html class="no-js" lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Experiment | Taak</title>
    <link rel="stylesheet" href="../css/normalize.css">
    <link rel="stylesheet" href="../css/foundation.css">
    <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,700" />
    <script src="../js/vendor/modernizr.js"></script>
    <script src="../js/konva.min.js"></script>
    <style>
        #container {
            background-color: black;
        }
    </style>
</head>

<body>

    <div class="row">
        <div class="large-8 large-offset-1 columns">
            <h1>Experiment</h1>
        </div>
    </div>

    <div class="row">
        <div class="large-10 small-centered columns">
            <div class="panel">
                <p>Klik op de knop om te starten.</p>
                <div class="row">
                    <div class="large-8 small-centered columns">
                        <div id="container"></div>
                        <p></p>
                    </div>
                </div>
                <div class="row">
                    <div class="large-2 small-centered columns">
                        <a href="#" class="small button" id="expButton">Start!</a>
                    </div>

                </div>
            </div>
        </div>
    </div>
    <script type="text/javascript">
        var submitted = false;
    </script>
    <iframe name="hidden_iframe" id="hidden_iframe" style="display:none;" onload="if(submitted)
{window.location='bedankt.html';}"></iframe>


    <form action="https://docs.google.com/forms/d/1wfm7qJHLoOtLPZ0voKYmY4V5R78xagF8buKmeX_l3H0/formResponse" method="POST" id="dataform" target="hidden_iframe" onsubmit="submitted=true;">

        <input type="hidden" name="entry.297871845" value="" id="ppn" dir="auto">
        <input type="hidden" name="entry.1482519923" id="rawData" dir="auto">

        <input type="hidden" name="draftResponse" value="[,,&quot;6116801903347109571&quot;]">
        <input type="hidden" name="pageHistory" value="0">
        <input type="hidden" name="fromEmail" value="false">
        <input type="hidden" name="fbzx" value="6116801903347109571">
    </form>



    <script src="../js/vendor/jquery.js"></script>
    <script src="../js/foundation.min.js"></script>
    <script>
        $(document).foundation();
    </script>
    <script defer="defer">
        var locations = {
            0: [70, 180],
            1: [310, 180]
        };


        var sources = {
            pos: 'img/pos.png',
            neg: 'img/neg.png',
            "000": 'img/bcs.png',
            "100": 'img/gcs.png',
            "010": 'img/bts.png',
            "110": 'img/gts.png',
            "001": 'img/bcd.png',
            "101": 'img/gcd.png',
            "111": 'img/gtd.png',
            "011": 'img/btd.png',
        };

        var dims = {
            0: "KLEUR", // blauw=b=0, geel=g=1
            1: "VORM", // cirkel=c=0, triangle=t=1
            2: "PATROON", //strepen=s=0, dots=d=1
        }

        var kleur = {
            0: "blauw",
            1: "groen"
        }

        features = [
            ["blauw", "groen"],
            ["cirkel", "driehoek"],
            ["streepjes", "bolletjes"]
        ]

        var stimPairs = [
            [
                [0, 0, 0],
                [1, 1, 1]
            ],
            [
                [1, 0, 0],
                [0, 1, 1]
            ],
            [
                [1, 1, 0],
                [0, 0, 1]
            ],
            [
                [0, 1, 0],
                [1, 0, 1]
            ]
        ]

        var stimPairSingleDim = [
            [0, 1, 1],
            [1, 1, 1]
        ]

        var expButton = $('#expButton');
        expButton.hide()
        var datastring = ""





        function getParameterByName(name) {
            name = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
            var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
                results = regex.exec(location.search);
            return results == null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
        }

        var ppn = getParameterByName('ppn');
        //ppn = parseInt(ppn);

        if (ppn == null || ppn == "") {
            ppn = 'dummy';
        }

        function randrange(lower, upperbound) {
            // Finds a random integer from 'lower' to 'upperbound-1'
            return Math.floor(Math.random() * upperbound + lower);
        }

        // Fisher-Yates shuffle algorithm.
        // modified from http://sedition.com/perl/javascript-fy.html

        function shuffle(arr, exceptions) {
            var i;
            exceptions = exceptions || [];
            var shufflelocations = new Array();
            for (i = 0; i < arr.length; i++) {
                if (exceptions.indexOf(i) == -1) {
                    shufflelocations.push(i);
                }
            }
            for (i = shufflelocations.length - 1; i >= 0; --i) {
                var loci = shufflelocations[i];
                var locj = shufflelocations[randrange(0, i + 1)];
                var tempi = arr[loci];
                var tempj = arr[locj];
                arr[loci] = tempj;
                arr[locj] = tempi;
            }
            return arr;
        }


        // Find the right method, call on correct element
        function launchFullScreen(element) {
            if (element.requestFullScreen) {
                element.requestFullScreen();
            } else if (element.mozRequestFullScreen) {
                element.mozRequestFullScreen();
            } else if (element.webkitRequestFullScreen) {
                element.webkitRequestFullScreen();
            }
        }


        function loadImages(sources, callback) {
            var images = {};
            var loadedImages = 0;
            var numImages = 0;
            // get num of sources
            for (var src in sources) {
                numImages++;
            }
            for (var src in sources) {
                images[src] = new Image();
                images[src].onload = function() {
                    if (++loadedImages >= numImages) {
                        callback(images);
                    }
                };
                images[src].src = sources[src];
            }
            return images
        }



        var images = loadImages(sources, runExp)

        function runExp() {

            expButton.show()
            var blockSizes = [20, 15, 15, randrange(15, 25), randrange(15, 25),15]
            var cuedList = [true, true, true, true, false, false]
            var rewardProbs = [.75, .8, .8, .8, .8, .8]
            var nbofdimsList = [1, 3, 3, 3, 3, 2] // only 1 or 3 dims are supported for now
            var nbofblocks = blockSizes.length

            var iti = 700 // for iti (blank)
            var fbdur = 700 // for feedback duration
            var cuedur = 3000 // duration of cue
            var trialnb = 0; //keeps track of current trialnb
            var blocknb = 0
            var timestart = 0;
            var pointsEarned = 0;
            var listening = false;

            var blocks = []
            var trial = {}
            var block = {}


            var stage = new Konva.Stage({
                container: 'container',
                width: 500,
                height: 500
            });
            var layer = new Konva.Layer();

            var bg = new Konva.Rect({
                x: 0,
                y: 0,
                width: 500,
                height: 500,
                name: 'bg',
                fill: "black",
            });


            var smiley = new Konva.Image({
                x: 215,
                y: 215,
                image: images.pos,
                width: 70,
                height: 70,
                visible: false,
            });

            var limg = new Konva.Image({
                x: locations[0][0],
                y: locations[0][1],
                image: images["010"],
                width: 120,
                height: 120,
                visible: false
            });

            var rimg = new Konva.Image({
                x: locations[1][0],
                y: locations[1][1],
                image: images["001"],
                width: 120,
                height: 120,
                visible: false
            });

            var instructxt = new Konva.Text({
                x: stage.getWidth() / 2 - 150,
                y: stage.getHeight() / 2,
                text: 'COMPLEX TEXT\n\nAll the world\'s a stage.',
                fontSize: 18,
                fontFamily: 'Calibri',
                fill: 'white',
                width: 300,
                padding: 20,
                align: 'center',
                visible: false
            });

            var points = new Konva.Text({
                x: stage.getWidth() - 250,
                y: stage.getHeight() - 50,
                text: "Total points: " + String(pointsEarned),
                fontSize: 18,
                fontFamily: 'Calibri',
                fill: 'white',
                width: 300,
                padding: 20,
                align: 'center',
                visible: true
            });

            var rect = new Konva.Rect({
                x: stage.getWidth() / 2 - 150,
                y: stage.getHeight() / 2,
                stroke: 'white',
                strokeWidth: 5,
                fill: 'white',
                width: 300,
                height: instructxt.getHeight(),
                shadowColor: 'white',
                shadowBlur: 10,
                shadowOffset: [10, 10],
                shadowOpacity: 0.2,
                cornerRadius: 10,
                visible: false
            });


            /*
             * create a group which will be used to combine
             * multiple simple shapes.  Transforming the group will
             * transform all of the simple shapes together as
             * one unit
             */
            var group = new Konva.Group({
                x: 0,
                y: 0,
                offsetX: 0,
                offsetY: 0,
            });

            for (var n = 0; n < 2; n++) {


                var box = new Konva.Rect({
                    x: locations[n][0],
                    y: locations[n][1],
                    width: 120,
                    height: 120,
                    name: String(n),
                    stroke: "grey",
                    strokeWidth: 1,
                    dash: [5, 5],
                });

                box.on('mouseover', function() {

                    this.dashEnabled(false);
                    this.strokeWidth(3);
                    layer.draw();
                });

                box.on('mouseout', function() {
                    this.dashEnabled(true);
                    this.strokeWidth(1);
                    layer.draw();
                });

                group.add(box);

                box.on('mousedown touchstart', function() {

                    if (!listening) return

                    trial.rt = new Date().getTime() - timestart;
                    listening = false
                    trial.respBox = parseInt(this.name());
                    this.strokeWidth(3);
                    feedback()
                });
            }






            layer.add(bg);
            layer.add(rimg);
            layer.add(limg);
            layer.add(group);
            layer.add(smiley);
            layer.add(rect);
            layer.add(points);
            layer.add(instructxt);

            stage.add(layer);






            expButton.click(function() {
                // Launch fullscreen for browsers that support it!
                //launchFullScreen(document.documentElement); // the whole page
                init()
                expButton.off('click');
                expButton.hide()
            });


            function feedback() {

                if (trial.respBox == trial.rewardedStim) {
                    smiley.setImage(images.pos);
                    trial.acc = 1;
                    pointsEarned++
                    var pointstxt = "Total points: " + String(pointsEarned)
                    points.setText(pointstxt)
                } else {
                    smiley.setImage(images.neg);
                    trial.acc = 0;
                }

                points.show()
                smiley.show()
                layer.draw();

                recordTrial();

                setTimeout(function() {
                    smiley.hide();
                    limg.hide()
                    rimg.hide()
                    layer.draw();

                    setTimeout(function() {
                        trialnb++;
                        next()
                    }, iti)

                }, fbdur);
            }

            function instruction() {


                if (blocknb == 3) var msg = "Let op: Vanaf nu geven we de veranderingen niet meer aan!"
                else var msg = "Let op: Nu is enkel " + String(dims[blocks[blocknb].relevantDim]) + " relevant!"

                instructxt.setText(msg)
                rect.height(instructxt.getHeight())
                instructxt.fill('#008cba')
                rect.stroke('#008cba')

                instructxt.show()
                rect.show()
                layer.draw()

                setTimeout(function() {
                    instructxt.hide();
                    rect.hide()
                    layer.draw();
                    next()

                }, cuedur);
            }

            function presentTrial() {

                limg.setImage(images[trial.stimPair[0].join("")]);
                rimg.setImage(images[trial.stimPair[1].join("")]);
                limg.show()
                rimg.show()

                layer.draw();
                listening = true

                timestart = new Date().getTime();
            }

            function recordTrial(respBox, acc, rt) {

                if (trial.respBox == trial.validStim) {
                    trial.consistency = 1
                } else {
                    trial.consistency = 0
                }

                trial.relevantDim = dims[block.relevantDim]
                trial.rewardedFeat = features[block.relevantDim][block.rewardedFeat]

                var trialvals = JSON.stringify(trial);
                console.log(trialvals)
                datastring = datastring.concat(trialvals, "\n");


            }

            function finish() {

                document.getElementById('ppn').value = ppn;
                document.getElementById('rawData').value = datastring;
                $('#dataform').submit();

            }

            var next = function() {

                //console.log(blocknb, trialnb);
                if (trialnb == blocks[blocknb].nboftrials) {
                    trialnb = 0 //reset trial counter
                    blocknb++ // set to next block
                    block = blocks[blocknb]

                    if (blocknb == nbofblocks) finish()
                    else if (block.cued) instruction() // show cue
                    else next()

                } else { //run trials
                    trial = blocks[blocknb].trials[trialnb];
                    presentTrial();
                }
            };

            function generateTrials() {




                for (var i = 0; i < nbofblocks; i++) {


                    var block = {
                        rewardProb: rewardProbs[i],
                        nbofdims: nbofdimsList[i],
                        nboftrials: blockSizes[i],
                        relevantDim: randrange(0, nbofdimsList[i]), // random selection of relevant dimension in this block
                        rewardedFeat: randrange(0, 2), // random selection of rewarded feature in this block
                        cued: cuedList[i],
                        trials: []
                    };

                    if (i > 0) { //make sure there is a switch relative to previous block
                        while (block.nbofdims != 1 && block.relevantDim == blocks[i - 1].relevantDim) {
                            block.relevantDim = randrange(0, nbofdimsList[i])
                        }
                        while (block.rewardedFeat == blocks[i - 1].rewardedFeat) {
                            block.rewardedFeat = randrange(0, 2)
                        }
                    }

                    for (var j = 0; j < block.nboftrials; j++) {

                        if (block.nbofdims == 1) {
                            thisStimPair = stimPairSingleDim.slice()
                        } else thisStimPair = stimPairs[randrange(0, stimPairs.length)].slice() //pick a stimulus pair

                        shuffle(thisStimPair) // reverse order of pair for half of the cases

                        var thisValidStim = 0
                        if (thisStimPair[1][block.relevantDim] == block.rewardedFeat) thisValidStim = 1 // if the second of the pair has the rewarded feature

                        var random = Math.random();

                        if (random < block.rewardProb) {
                            var thisValid = true;
                            var thisRewardedStim = thisValidStim
                        } else {
                            thisValid = false;
                            if (thisValidStim == 0) thisRewardedStim = 1
                            if (thisValidStim == 1) thisRewardedStim = 0
                        }

                        var trial = {
                            ppn: ppn,
                            blocknb: i,
                            trialnb: j,
                            nboftrials: block.nboftrials,
                            stimPair: thisStimPair,
                            valid: thisValid, // is it a valid trial? (boolean)
                            validStim: thisValidStim, // which stim holds rewarded feature for current rule
                            rewardedStim: thisRewardedStim, //which stim holds stim that is rewarded on this trial
                            rewardProb: block.rewardProb,
                            nbofdims: block.nbofdims,
                            relevantDim: block.relevantDim, // random selection of relevant dimension in this block
                            rewardedFeat: block.rewardedFeat, // random selection of rewarded feature in this block
                            cued: block.cued
                        }

                        block.trials.push(trial)
                    }
                    blocks.push(block)
                }
            }




            function init() {
                generateTrials();
                points.show()
                    //console.log(JSON.stringify(trials));
                block = blocks[blocknb]
                instruction();

            }



        }
    </script>
</body>

</html>
